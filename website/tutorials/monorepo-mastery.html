<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monorepo Mastery — Port Daddy Tutorials</title>
  <meta name="description" content="Orchestrate a 50-service monorepo with pd scan, pd up, dependency ordering, health checks, color-coded logs, and branch-specific configs.">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>%E2%9A%93</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;600&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/shared.css">
</head>
<body>
  <nav>
    <div class="nav-container">
      <a href="../" class="logo">
        <svg class="logo-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="3"/><line x1="12" y1="22" x2="12" y2="8"/><path d="M5 12H2a10 10 0 0 0 20 0h-3"/></svg>
        <span>Port Daddy</span>
      </a>
      <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Toggle navigation">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
      </button>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="./" class="active">Tutorials</a>
        <a href="../mcp/">MCP</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/curiositech/port-daddy" target="_blank">GitHub</a>
      </div>
    </div>
  </nav>

  <section class="page-hero">
    <div class="page-hero-container">
      <div class="breadcrumbs">
        <a href="../">Home</a>
        <span class="separator">/</span>
        <a href="./">Tutorials</a>
        <span class="separator">/</span>
        <span>Monorepo Mastery</span>
      </div>
      <h1>Port Daddy in a 50-Service Monorepo</h1>
      <p>Scan your entire monorepo, start the full stack in dependency order, and finally stop juggling 15 terminal tabs.</p>
      <div class="meta">
        <span class="meta-item">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
          14 min read
        </span>
        <span class="meta-item">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
          Tutorial 4 of 5
        </span>
        <span class="meta-item">Advanced</span>
      </div>
    </div>
  </section>

  <div class="content-layout">
    <aside class="toc">
      <h4>On this page</h4>
      <ul>
        <li><a href="#the-nightmare">The Monorepo Port Nightmare</a></li>
        <li><a href="#scanning">Scanning Your Monorepo</a></li>
        <li><a href="#starting-stack">Starting the Whole Stack</a></li>
        <li><a href="#dependencies">Intelligent Dependency Management</a></li>
        <li><a href="#individual-services">Starting Individual Services</a></li>
        <li><a href="#health-checks">Custom Health Checks</a></li>
        <li><a href="#env-vars">Environment Variables and Service Discovery</a></li>
        <li><a href="#logs">Logs with Color and Prefixes</a></li>
        <li><a href="#stopping">Stopping the Stack</a></li>
        <li><a href="#real-example">Real Monorepo Example</a></li>
        <li><a href="#branch-configs">Branch-Specific Configs</a></li>
        <li><a href="#health-monitoring">Health Monitoring</a></li>
        <li><a href="#sharing-config">Sharing Your Config</a></li>
        <li><a href="#whats-next">What's Next</a></li>
      </ul>
    </aside>

    <article class="article">
      <p>You work at PaymentCo. Fifteen services. Three databases. Two message queues. A search engine. And every developer on the team has a different way of starting it all -- a shell script here, a Docker Compose there, and the new hire is still waiting for someone to tell them which port the API runs on.</p>

      <h2 id="the-nightmare">The Monorepo Port Nightmare</h2>
      <p>Here is what monorepo development looks like without orchestration:</p>
      <pre><code><span class="output">Monday:
  "API is on 3000, frontend on 3001, worker on 3002"

Tuesday:
  "Wait, Dave changed the API to 4000 in his branch"
  "The worker is failing because it's hardcoded to call localhost:3000"

Wednesday:
  "Docker Compose is fighting with my local postgres"
  "Who left a zombie redis-server on port 6379?"

Thursday:
  "I just need the frontend. Why am I starting all 15 services?"
  "Elasticsearch is eating 4GB of RAM and I'm not even using search"

Friday:
  "I give up. I'm just going to work on the mobile app."</span></code></pre>
      <p>The core problems are always the same:</p>
      <ul>
        <li><strong>Port collisions</strong> -- Teams pick random ports, commit them to config, and break each other</li>
        <li><strong>Merge conflicts</strong> -- Two PRs change the same <code>.env</code> file with different port numbers</li>
        <li><strong>Docker zombies</strong> -- Containers from last week still holding ports hostage</li>
        <li><strong>Startup ordering</strong> -- The API crashes because postgres isn't ready yet</li>
        <li><strong>All-or-nothing</strong> -- No way to start just the services you need</li>
        <li><strong>Log chaos</strong> -- 15 services dumping to the same terminal with no way to tell them apart</li>
      </ul>
      <p>Port Daddy solves every single one of these. Let's walk through it.</p>

      <h2 id="scanning">Scanning Your Monorepo</h2>
      <p>First, let Port Daddy understand what you're working with. The <code>pd scan</code> command recursively walks your directory tree and detects every service it finds:</p>
      <pre><code><span class="prompt">$</span> cd ~/code/paymentco
<span class="prompt">$</span> pd scan

<span class="output">Scanning /Users/you/code/paymentco...
Found 15 services in 3.2s

  services/api           Next.js (App Router)     needs: [postgres, redis]
  services/admin         Next.js                  needs: [api]
  services/dashboard     Vite + React             needs: [api]
  services/worker        Node.js (custom)         needs: [postgres, redis, nats]
  services/scheduler     Node.js (custom)         needs: [postgres, redis]
  services/webhooks      Express                  needs: [postgres, nats]
  services/search-sync   Node.js (custom)         needs: [postgres, elasticsearch]
  services/email         Fastify                  needs: [redis, nats]
  services/auth          Express                  needs: [postgres, redis]
  services/billing       NestJS                   needs: [postgres, redis, nats]
  services/notifications Hono                     needs: [redis, nats]
  infra/postgres         PostgreSQL 16            standalone
  infra/redis            Redis 7                  standalone
  infra/nats             NATS                     standalone
  infra/elasticsearch    Elasticsearch 8          standalone

Wrote .portdaddyrc (15 services, 23 dependencies)</span></code></pre>
      <p>Port Daddy detects 60+ frameworks -- Next.js, Express, Fastify, NestJS, Hono, Django, Rails, Spring Boot, Go, Rust, and many more. It reads <code>package.json</code>, <code>Cargo.toml</code>, <code>go.mod</code>, <code>requirements.txt</code>, and other manifest files to determine the framework and its default start command.</p>
      <p>The generated <code>.portdaddyrc</code> captures your entire architecture:</p>
      <pre><code>{
  <span class="string">"project"</span>: <span class="string">"paymentco"</span>,
  <span class="string">"services"</span>: {
    <span class="string">"postgres"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"pg_ctl -D /usr/local/var/postgresql@16 start"</span>,
      <span class="string">"health"</span>: <span class="string">"pg_isready -h localhost -p ${PORT}"</span>,
      <span class="string">"shutdownCmd"</span>: <span class="string">"pg_ctl -D /usr/local/var/postgresql@16 stop"</span>
    },
    <span class="string">"redis"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"redis-server --port ${PORT}"</span>,
      <span class="string">"health"</span>: <span class="string">"redis-cli -p ${PORT} ping"</span>
    },
    <span class="string">"nats"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"nats-server -p ${PORT}"</span>,
      <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:${PORT}/healthz"</span>
    },
    <span class="string">"elasticsearch"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"elasticsearch -E http.port=${PORT}"</span>,
      <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:${PORT}/_cluster/health"</span>,
      <span class="string">"healthTimeout"</span>: 30
    },
    <span class="string">"api"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev -- --port ${PORT}"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/api"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
    },
    <span class="string">"dashboard"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev -- --port ${PORT}"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/dashboard"</span>,
      <span class="string">"needs"</span>: [<span class="string">"api"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/"</span>
    }
  }
}</code></pre>
      <p>Notice there are zero hardcoded ports anywhere. Every <code>${PORT}</code> reference is filled in dynamically by Port Daddy at start time. Commit this file to your repo -- every developer gets the same config.</p>

      <h2 id="starting-stack">Starting the Whole Stack</h2>
      <p>Now the moment of truth. One command to start everything:</p>
      <pre><code><span class="prompt">$</span> pd up

<span class="output">[paymentco] Starting 15 services...

  [postgres]        Starting on port 5532...
  [redis]           Starting on port 6479...
  [nats]            Starting on port 4322...
  [elasticsearch]   Starting on port 9300...

  [postgres]        Health check passed (0.3s)
  [redis]           Health check passed (0.1s)
  [nats]            Health check passed (0.2s)
  [elasticsearch]   Health check passed (8.4s)

  [auth]            Starting on port 3100...
  [api]             Starting on port 3101...
  [worker]          Starting on port 3102...
  [scheduler]       Starting on port 3103...
  [webhooks]        Starting on port 3104...
  [billing]         Starting on port 3105...
  [search-sync]     Starting on port 3106...
  [email]           Starting on port 3107...
  [notifications]   Starting on port 3108...

  [auth]            Health check passed (1.2s)
  [api]             Health check passed (2.1s)
  [worker]          Health check passed (0.8s)
  [billing]         Health check passed (1.9s)

  [admin]           Starting on port 3109...
  [dashboard]       Starting on port 3110...

  [admin]           Health check passed (1.4s)
  [dashboard]       Health check passed (1.1s)

All 15 services healthy. Total startup: 14.3s</span></code></pre>
      <p>What just happened:</p>
      <ol>
        <li><strong>Dependency resolution</strong> -- Port Daddy built a directed acyclic graph (DAG) from the <code>needs</code> fields</li>
        <li><strong>Parallel startup</strong> -- Independent services (postgres, redis, nats, elasticsearch) started simultaneously</li>
        <li><strong>Health gate</strong> -- Services that depend on infra waited until health checks passed</li>
        <li><strong>Second wave</strong> -- API-level services started after infra was healthy</li>
        <li><strong>Third wave</strong> -- Frontend services started after the API was healthy</li>
        <li><strong>Port injection</strong> -- Every service received its deterministic port via <code>${PORT}</code></li>
      </ol>
      <p>Compare this to your old <code>start-everything.sh</code> script that was 200 lines of <code>sleep 5</code> calls and hardcoded ports.</p>

      <h2 id="dependencies">Intelligent Dependency Management</h2>
      <p>The <code>needs</code> field is the heart of the orchestrator. Port Daddy resolves the full dependency graph before starting anything:</p>
      <pre><code>{
  <span class="string">"api"</span>: {
    <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>]
  },
  <span class="string">"dashboard"</span>: {
    <span class="string">"needs"</span>: [<span class="string">"api"</span>]
  },
  <span class="string">"billing"</span>: {
    <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>, <span class="string">"nats"</span>]
  }
}</code></pre>
      <p>From this, Port Daddy computes the start order:</p>
      <pre><code><span class="output">Wave 1: postgres, redis, nats, elasticsearch  (no dependencies)
Wave 2: api, auth, worker, scheduler, webhooks, billing, search-sync, email, notifications
Wave 3: admin, dashboard  (depend on api)</span></code></pre>
      <p>Within each wave, services start in parallel. Between waves, Port Daddy waits for every health check to pass before moving on.</p>
      <p>If you create a circular dependency, Port Daddy catches it immediately:</p>
      <pre><code><span class="prompt">$</span> pd up
<span class="output">Error: Circular dependency detected: api -> billing -> api
Fix the "needs" chain in .portdaddyrc before starting.</span></code></pre>

      <h2 id="individual-services">Starting Individual Services</h2>
      <p>You don't always need all 15 services. If you're working on the dashboard, you only need the dashboard plus whatever it depends on:</p>
      <pre><code><span class="prompt">$</span> pd up --service dashboard

<span class="output">[paymentco] Resolving dependencies for: dashboard
  dashboard -> api -> postgres, redis

Starting 4 services...

  [postgres]   Starting on port 5532...  Health check passed (0.3s)
  [redis]      Starting on port 6479...  Health check passed (0.1s)
  [api]        Starting on port 3101...  Health check passed (2.1s)
  [dashboard]  Starting on port 3110...  Health check passed (1.1s)

4 of 15 services started. Skipped: nats, elasticsearch, worker, scheduler,
  webhooks, billing, search-sync, email, notifications, auth, admin</span></code></pre>
      <p>Port Daddy walks the dependency tree backward from your target service and starts exactly what's needed -- nothing more. You saved yourself from launching elasticsearch (4GB of RAM) and NATS (not needed for dashboard work) while still getting a working API with its database.</p>
      <p>You can start multiple specific services too:</p>
      <pre><code><span class="comment"># Start just the billing and webhooks stacks</span>
<span class="prompt">$</span> pd up --service billing --service webhooks

<span class="output">[paymentco] Resolving dependencies for: billing, webhooks
  billing  -> postgres, redis, nats
  webhooks -> postgres, nats

Starting 5 services (deduplicated)...</span></code></pre>

      <h2 id="health-checks">Custom Health Checks</h2>
      <p>Different services need different health checks. Port Daddy supports three types:</p>

      <h3>HTTP Health Checks (default)</h3>
      <p>For web services, specify a path that returns 200:</p>
      <pre><code>{
  <span class="string">"api"</span>: {
    <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
  }
}</code></pre>
      <p>Port Daddy polls <code>http://localhost:{port}/health</code> until it gets a 200 status code.</p>

      <h3>Command Health Checks</h3>
      <p>For databases and infrastructure, use a shell command:</p>
      <pre><code>{
  <span class="string">"postgres"</span>: {
    <span class="string">"health"</span>: <span class="string">"pg_isready -h localhost -p ${PORT}"</span>
  },
  <span class="string">"redis"</span>: {
    <span class="string">"health"</span>: <span class="string">"redis-cli -p ${PORT} ping"</span>
  },
  <span class="string">"elasticsearch"</span>: {
    <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:${PORT}/_cluster/health"</span>,
    <span class="string">"healthTimeout"</span>: 30
  },
  <span class="string">"nats"</span>: {
    <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:${PORT}/healthz"</span>
  }
}</code></pre>
      <p>The command is re-executed every second until it returns exit code 0 or the timeout is reached.</p>

      <h3>TCP Health Checks</h3>
      <p>For services that just need a port to be open:</p>
      <pre><code>{
  <span class="string">"custom-tcp-service"</span>: {
    <span class="string">"healthMode"</span>: <span class="string">"tcp"</span>
  }
}</code></pre>

      <h3>Health Timeout</h3>
      <p>Slow services like Elasticsearch can take 30 seconds to start. Set a custom timeout:</p>
      <pre><code>{
  <span class="string">"elasticsearch"</span>: {
    <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:${PORT}/_cluster/health"</span>,
    <span class="string">"healthTimeout"</span>: 60
  }
}</code></pre>
      <p>If a health check exceeds its timeout, Port Daddy reports the failure and continues starting other services that don't depend on it.</p>

      <h2 id="env-vars">Environment Variables and Service Discovery</h2>
      <p>When Port Daddy starts a service, it injects environment variables for every other running service. Your application code never needs to hardcode a port number:</p>
      <pre><code><span class="comment"># Environment injected into the "api" service:</span>
<span class="output">PORT=3101                              # This service's own port
PORT_postgres=5532                     # Postgres port
PORT_redis=6479                        # Redis port
PORT_nats=4322                         # NATS port
PORT_elasticsearch=9300                # Elasticsearch port
PORTDADDY_PROJECT=paymentco            # Project name
PORTDADDY_SERVICE=api                  # This service's name</span></code></pre>
      <p>In your application code, reference these instead of hardcoded values:</p>
      <pre><code><span class="comment">// services/api/src/config.ts</span>
<span class="keyword">export const</span> config = {
  port: process.env.PORT,
  database: {
    host: <span class="string">'localhost'</span>,
    port: parseInt(process.env.PORT_postgres || <span class="string">'5432'</span>),
  },
  redis: {
    host: <span class="string">'localhost'</span>,
    port: parseInt(process.env.PORT_redis || <span class="string">'6379'</span>),
  },
  nats: {
    url: <span class="string">`nats://localhost:</span>${process.env.PORT_nats || <span class="string">'4222'</span>}<span class="string">`</span>,
  },
};</code></pre>
      <p>The fallback values (<code>5432</code>, <code>6379</code>, <code>4222</code>) are the standard default ports, so your code still works when running outside of Port Daddy. But inside the orchestrator, the <code>PORT_*</code> variables always point to the correct dynamically-assigned port.</p>
      <p>You can also define custom environment variables per service:</p>
      <pre><code>{
  <span class="string">"api"</span>: {
    <span class="string">"env"</span>: {
      <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span>,
      <span class="string">"LOG_LEVEL"</span>: <span class="string">"debug"</span>,
      <span class="string">"DATABASE_URL"</span>: <span class="string">"postgresql://localhost:${PORT_postgres}/paymentco_dev"</span>
    }
  }
}</code></pre>

      <h2 id="logs">Logs with Color and Prefixes</h2>
      <p>With 15 services writing to stdout, you need to know which line came from which service. Port Daddy prefixes every line with a color-coded service name:</p>
      <pre><code><span class="output">[postgres]        2026-03-01 10:00:01 LOG: database system is ready
[redis]           10:00:01 Ready to accept connections on port 6479
[nats]            [INF] Starting nats-server
[api]             > next dev --port 3101
[api]             ready - started server on 0.0.0.0:3101
[worker]          Connected to NATS on port 4322
[dashboard]       VITE v6.1.0 ready in 340ms
[billing]         [Nest] LOG NestApplication successfully started
[search-sync]     Connected to Elasticsearch on port 9300
[email]           Server listening on port 3107</span></code></pre>
      <p>Each service gets a consistent color. Infrastructure services are one hue, backend services another, and frontend services a third. The colors are deterministic -- postgres is always the same color on your machine.</p>
      <p>Logs are also grep-able. Because each line is prefixed, you can filter in real time:</p>
      <pre><code><span class="comment"># Follow only the API logs</span>
<span class="prompt">$</span> pd up 2>&1 | grep <span class="string">"\[api\]"</span>

<span class="comment"># Follow API and billing together</span>
<span class="prompt">$</span> pd up 2>&1 | grep -E <span class="string">"\[(api|billing)\]"</span>

<span class="comment"># Filter for errors across all services</span>
<span class="prompt">$</span> pd up 2>&1 | grep -i <span class="string">"error"</span></code></pre>

      <h2 id="stopping">Stopping the Stack</h2>
      <p>When you're done, one command shuts everything down:</p>
      <pre><code><span class="prompt">$</span> pd down

<span class="output">[paymentco] Stopping 15 services...

  [dashboard]       Stopped (SIGTERM)
  [admin]           Stopped (SIGTERM)
  [notifications]   Stopped (SIGTERM)
  [email]           Stopped (SIGTERM)
  [search-sync]     Stopped (SIGTERM)
  [billing]         Stopped (SIGTERM)
  [webhooks]        Stopped (SIGTERM)
  [scheduler]       Stopped (SIGTERM)
  [worker]          Stopped (SIGTERM)
  [api]             Stopped (SIGTERM)
  [auth]            Stopped (SIGTERM)
  [elasticsearch]   Stopped (SIGTERM)
  [nats]            Stopped (SIGTERM)
  [redis]           Stopped (SIGTERM)
  [postgres]        Stopped (pg_ctl stop)

All 15 services stopped. Ports released.</span></code></pre>
      <p>Notice the order: <strong>reverse dependency order</strong>. Frontend services stop first, then backend services, then infrastructure. This prevents errors from services trying to reach dependencies that have already been killed.</p>
      <p>Services that define a <code>shutdownCmd</code> (like postgres) use their graceful shutdown command instead of raw SIGTERM. This ensures data integrity.</p>
      <p>You can also stop individual services:</p>
      <pre><code><span class="comment"># Stop just the dashboard (leaves its dependencies running)</span>
<span class="prompt">$</span> pd down --service dashboard

<span class="comment"># Stop elasticsearch and everything that depends on it</span>
<span class="prompt">$</span> pd down --service elasticsearch --cascade
<span class="output">Stopping: search-sync, elasticsearch (cascade)</span></code></pre>

      <h2 id="real-example">Real Monorepo Example</h2>
      <p>Here's a complete <code>.portdaddyrc</code> for a 15-service payment processing company. This is a real-world config, not a simplified tutorial example:</p>
      <pre><code>{
  <span class="string">"project"</span>: <span class="string">"paymentco"</span>,
  <span class="string">"services"</span>: {
    <span class="string">"postgres"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"pg_ctl -D /usr/local/var/postgresql@16 -l /tmp/pg.log start"</span>,
      <span class="string">"health"</span>: <span class="string">"pg_isready -h localhost -p ${PORT}"</span>,
      <span class="string">"shutdownCmd"</span>: <span class="string">"pg_ctl -D /usr/local/var/postgresql@16 stop -m fast"</span>,
      <span class="string">"healthTimeout"</span>: 10
    },
    <span class="string">"redis"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"redis-server --port ${PORT} --daemonize no"</span>,
      <span class="string">"health"</span>: <span class="string">"redis-cli -p ${PORT} ping"</span>
    },
    <span class="string">"nats"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"nats-server -p ${PORT} -m 8222"</span>,
      <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:8222/healthz"</span>
    },
    <span class="string">"elasticsearch"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"elasticsearch -E http.port=${PORT} -E transport.port=9400"</span>,
      <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:${PORT}/_cluster/health"</span>,
      <span class="string">"healthTimeout"</span>: 60,
      <span class="string">"env"</span>: { <span class="string">"ES_JAVA_OPTS"</span>: <span class="string">"-Xms512m -Xmx512m"</span> }
    },
    <span class="string">"auth"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/auth"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>,
      <span class="string">"env"</span>: {
        <span class="string">"JWT_SECRET"</span>: <span class="string">"dev-secret-do-not-use-in-prod"</span>,
        <span class="string">"DATABASE_URL"</span>: <span class="string">"postgresql://localhost:${PORT_postgres}/paymentco_auth"</span>
      }
    },
    <span class="string">"api"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/api"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>, <span class="string">"auth"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/api/health"</span>,
      <span class="string">"env"</span>: {
        <span class="string">"DATABASE_URL"</span>: <span class="string">"postgresql://localhost:${PORT_postgres}/paymentco_dev"</span>,
        <span class="string">"REDIS_URL"</span>: <span class="string">"redis://localhost:${PORT_redis}"</span>,
        <span class="string">"AUTH_SERVICE_URL"</span>: <span class="string">"http://localhost:${PORT_auth}"</span>
      }
    },
    <span class="string">"worker"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run worker"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/worker"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>, <span class="string">"nats"</span>],
      <span class="string">"noPort"</span>: <span class="keyword">true</span>,
      <span class="string">"health"</span>: <span class="string">"curl -sf http://localhost:${PORT}/worker/health"</span>
    },
    <span class="string">"billing"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/billing"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>, <span class="string">"nats"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>,
      <span class="string">"env"</span>: {
        <span class="string">"STRIPE_KEY"</span>: <span class="string">"sk_test_placeholder"</span>,
        <span class="string">"NATS_URL"</span>: <span class="string">"nats://localhost:${PORT_nats}"</span>
      }
    },
    <span class="string">"webhooks"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/webhooks"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"nats"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
    },
    <span class="string">"scheduler"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/scheduler"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"redis"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
    },
    <span class="string">"search-sync"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/search-sync"</span>,
      <span class="string">"needs"</span>: [<span class="string">"postgres"</span>, <span class="string">"elasticsearch"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
    },
    <span class="string">"email"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/email"</span>,
      <span class="string">"needs"</span>: [<span class="string">"redis"</span>, <span class="string">"nats"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
    },
    <span class="string">"notifications"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/notifications"</span>,
      <span class="string">"needs"</span>: [<span class="string">"redis"</span>, <span class="string">"nats"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
    },
    <span class="string">"admin"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/admin"</span>,
      <span class="string">"needs"</span>: [<span class="string">"api"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/"</span>
    },
    <span class="string">"dashboard"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/dashboard"</span>,
      <span class="string">"needs"</span>: [<span class="string">"api"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/"</span>
    }
  }
}</code></pre>
      <p>Fifteen services. Zero hardcoded ports. Full dependency graph. Any developer can clone the repo, run <code>pd up</code>, and have the entire stack running in under 20 seconds.</p>

      <h2 id="branch-configs">Branch-Specific Configs</h2>
      <p>Sometimes a feature branch changes the service topology. Maybe you're adding a new <code>fraud-detection</code> service or temporarily splitting the API into two. Use branch-specific overrides:</p>
      <pre><code><span class="prompt">$</span> pd up --branch feature/fraud-detection

<span class="output">[paymentco] Loading .portdaddyrc
[paymentco] Applying branch override: .portdaddyrc.feature-fraud-detection
[paymentco] Added service: fraud-detection (needs: [api, redis, nats])
Starting 16 services...</span></code></pre>
      <p>The branch override file (<code>.portdaddyrc.feature-fraud-detection</code>) merges with the base config:</p>
      <pre><code>{
  <span class="string">"services"</span>: {
    <span class="string">"fraud-detection"</span>: {
      <span class="string">"cmd"</span>: <span class="string">"npm run dev"</span>,
      <span class="string">"cwd"</span>: <span class="string">"services/fraud-detection"</span>,
      <span class="string">"needs"</span>: [<span class="string">"api"</span>, <span class="string">"redis"</span>, <span class="string">"nats"</span>],
      <span class="string">"healthPath"</span>: <span class="string">"/health"</span>
    },
    <span class="string">"api"</span>: {
      <span class="string">"env"</span>: {
        <span class="string">"FRAUD_SERVICE_URL"</span>: <span class="string">"http://localhost:${PORT_fraud-detection}"</span>
      }
    }
  }
}</code></pre>
      <p>The override adds the new service and injects its URL into the API's environment. When you merge the branch, the override file goes away and the base config is unchanged.</p>

      <h2 id="health-monitoring">Health Monitoring</h2>
      <p>Once the stack is running, Port Daddy continuously monitors service health. Check the status at any time:</p>
      <pre><code><span class="prompt">$</span> pd status

<span class="output">paymentco (15 services)

  Service          Port   Status    Uptime     Last Check
  -------          ----   ------    ------     ----------
  postgres         5532   healthy   2h 14m     2s ago
  redis            6479   healthy   2h 14m     1s ago
  nats             4322   healthy   2h 14m     3s ago
  elasticsearch    9300   healthy   2h 13m     5s ago
  auth             3100   healthy   2h 13m     2s ago
  api              3101   healthy   2h 13m     1s ago
  worker           3102   healthy   2h 13m     4s ago
  scheduler        3103   healthy   2h 12m     2s ago
  webhooks         3104   healthy   2h 12m     3s ago
  billing          3105   healthy   2h 12m     2s ago
  search-sync      3106   healthy   2h 11m     6s ago
  email            3107   healthy   2h 11m     1s ago
  notifications    3108   healthy   2h 11m     2s ago
  admin            3109   healthy   2h 10m     3s ago
  dashboard        3110   healthy   2h 10m     1s ago</span></code></pre>
      <p>If a service crashes, Port Daddy detects it within seconds:</p>
      <pre><code><span class="prompt">$</span> pd status

<span class="output">  api              3101   DOWN      --         0s ago
  dashboard        3110   unhealthy 2h 15m     1s ago  (upstream: api)</span></code></pre>
      <p>The dashboard is marked unhealthy because its upstream dependency (the API) is down. You can see exactly where the problem originates.</p>
      <p>Check the health of a single service from the CLI or via HTTP:</p>
      <pre><code><span class="comment"># CLI</span>
<span class="prompt">$</span> pd health paymentco:api

<span class="comment"># HTTP</span>
<span class="prompt">$</span> curl http://localhost:9876/services/health/paymentco:api
<span class="output">{"id":"paymentco:api","port":3101,"status":"healthy","latency":"12ms"}</span></code></pre>

      <h2 id="sharing-config">Sharing Your Config</h2>
      <p>The <code>.portdaddyrc</code> file is designed to be committed to your repository. Every developer gets the same orchestration config:</p>
      <pre><code><span class="comment"># Commit the config</span>
<span class="prompt">$</span> git add .portdaddyrc
<span class="prompt">$</span> git commit -m <span class="string">"Add Port Daddy orchestration config"</span>

<span class="comment"># New developer experience</span>
<span class="prompt">$</span> git clone git@github.com:paymentco/monorepo.git
<span class="prompt">$</span> cd monorepo
<span class="prompt">$</span> pd up
<span class="output"># Everything starts. No README. No setup guide. No Slack questions.</span></code></pre>
      <p>Because ports are deterministically assigned from the service identity, every developer on the team gets the same port for the same service. The API is always on the same port, whether you're on a MacBook in Brooklyn or a Linux workstation in Berlin.</p>
      <p>Tips for maintaining the config in a team:</p>
      <ul>
        <li><strong>Keep it in the repo root</strong> -- Next to <code>package.json</code> and <code>docker-compose.yml</code></li>
        <li><strong>Use <code>.portdaddyrc.local</code> for personal overrides</strong> -- Add to <code>.gitignore</code></li>
        <li><strong>Document the <code>pd up</code> command in your README</strong> -- One line replaces a full setup guide</li>
        <li><strong>Use <code>pd scan</code> periodically</strong> -- Re-scan when you add new services to detect them automatically</li>
      </ul>

      <h2 id="whats-next">What's Next</h2>
      <p>You've learned how to orchestrate a full monorepo. The key insights:</p>
      <ul>
        <li><code>pd scan</code> auto-detects your services and generates the config</li>
        <li><code>pd up</code> starts everything in dependency order with health gates</li>
        <li><code>pd up --service</code> starts only what you need</li>
        <li><code>pd down</code> stops everything in reverse dependency order</li>
        <li>Zero hardcoded ports, deterministic assignment, sharable config</li>
      </ul>
      <p>Continue with:</p>
      <ol>
        <li><a href="debugging.html">Debugging</a> -- When services crash, health checks fail, or ports go missing</li>
        <li><a href="multi-agent-orchestration.html">Multi-Agent Orchestration</a> -- Add AI agents coordinating on top of your running stack</li>
        <li><a href="tunnel-magic.html">Tunnel Magic</a> -- Share your running monorepo with external testers via public URLs</li>
      </ol>
      <p>The hardest part of running a monorepo was never the code. It was getting the infrastructure to cooperate. That problem is now solved.</p>

      <div class="prev-next">
        <a href="tunnel-magic.html">
          <div class="label">Previous tutorial</div>
          <div class="title">Tunnel Magic</div>
        </a>
        <a href="debugging.html" class="next">
          <div class="label">Next tutorial</div>
          <div class="title">Debugging</div>
        </a>
      </div>
    </article>
  </div>

  <footer>
    <div class="footer-container">
      <div class="footer-grid">
        <div class="footer-brand">
          <a href="../" class="logo" style="color: white;">
            <svg class="logo-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="3"/><line x1="12" y1="22" x2="12" y2="8"/><path d="M5 12H2a10 10 0 0 0 20 0h-3"/></svg>
            <span>Port Daddy</span>
          </a>
          <p>Port management, service orchestration, and agent coordination for modern development workflows.</p>
        </div>
        <div class="footer-column">
          <h4>Product</h4>
          <ul><li><a href="../#features">Features</a></li><li><a href="../mcp/">MCP Integration</a></li><li><a href="https://www.npmjs.com/package/port-daddy" target="_blank">npm Package</a></li></ul>
        </div>
        <div class="footer-column">
          <h4>Resources</h4>
          <ul><li><a href="./">Tutorials</a></li><li><a href="../docs/">Documentation</a></li><li><a href="https://github.com/curiositech/port-daddy" target="_blank">GitHub</a></li></ul>
        </div>
        <div class="footer-column">
          <h4>Connect</h4>
          <ul><li><a href="https://github.com/curiositech" target="_blank">@curiositech</a></li></ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p>&copy; 2025–2026 Curiositech LLC. Released under the MIT License.</p>
      </div>
    </div>
  </footer>
</body>
</html>